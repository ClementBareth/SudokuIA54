/** 
 * 
 */
package fr.utbm.sudoku.agents

import fr.utbm.sudoku.events.Algos
import fr.utbm.sudoku.events.BlocReady
import fr.utbm.sudoku.events.EcoTokenReceived
import fr.utbm.sudoku.events.EcoTokenReleased
import fr.utbm.sudoku.events.EcoValue
import fr.utbm.sudoku.events.Exit
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.ResetEcoValues
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.SolutionFoundInBloc
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.events.Values
import fr.utbm.sudoku.model.Algorithms
import fr.utbm.sudoku.model.ContextContainer
import fr.utbm.sudoku.model.RegionTypeEnum
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberLeft
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.Collections
import java.util.List
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.locks.ReentrantLock
/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent BlocAgent {
	uses Logging, InnerContextAccess, Lifecycle, Behaviors, DefaultContextInteractions, Schedules

	var startRow : Integer
	var startCol : Integer
	var blocValues : List<Integer>
	var rowCtxIds : ConcurrentHashMap<Integer, ContextContainer>
	var colCtxIds : ConcurrentHashMap<Integer, ContextContainer>
	val agents = new ArrayList<UUID>
	var valuesLock = new ReentrantLock
	var tokens = new ConcurrentHashMap<UUID, Integer>
	var agentResolving : UUID = null
	var expectedTokens : Integer
	var tokenReleasedLock = new ReentrantLock
	var ecoTokens = new ConcurrentHashMap<UUID, Integer>
	var spawner : UUID

	on Initialize {
		if (occurrence.parameters.length >= 5) {
			this.startRow = occurrence.parameters.get(0) as Integer
			this.startCol = occurrence.parameters.get(1) as Integer
			this.blocValues = occurrence.parameters.get(2) as List<Integer>
			this.rowCtxIds = occurrence.parameters.get(3) as ConcurrentHashMap<Integer, ContextContainer>
			this.colCtxIds = occurrence.parameters.get(4) as ConcurrentHashMap<Integer, ContextContainer>
			loggingName = "Bloc n°(" + startRow + "," + startCol + ")"
		}
		spawner = occurrence.spawner
		for (var i = 0; i < 9; i++) {
			if (blocValues.get(i) === null || blocValues.get(i) == 0) {
				var row = startRow + i / 3 as Integer
				var col = startCol + i % 3
				agents.add(CellAgent.spawnInContext(innerContext, rowCtxIds.get(row), colCtxIds.get(col), row, col))
			}
		}
	}

	on Resolve [!it.isFrom(ID)] {
		wake(new Values => [values = blocValues; type = RegionTypeEnum.BLOC; it.agents = this.agents.toSet])
		if (occurrence.algos.contains(Algorithms.ECO_RESOLUTION) &&
			occurrence.algos.contains(Algorithms.HIDDEN_SINGLETONS)) {
			expectedTokens = 2
		} else if (occurrence.algos.contains(Algorithms.ECO_RESOLUTION) ||
			occurrence.algos.contains(Algorithms.HIDDEN_SINGLETONS)) {
			expectedTokens = 1
		}
		wake(new Algos => [algos = occurrence.algos])
	}

	on SolutionFound {
		agents.remove(occurrence.source.UUID)
		tokens.remove(occurrence.source.UUID)
		valuesLock.lock
		if (!blocValues.contains(occurrence.solution)) {
			blocValues.add(occurrence.solution)
			valuesLock.unlock
			emit(new SolutionFoundInBloc => [
				solution = occurrence.solution;
				x = occurrence.x;
				y = occurrence.y;
				definitive = true;
			])
		} else {
			valuesLock.unlock
		}
	}

	on Exit {
		wake(new Exit)
	}

	on MemberLeft {
		if(innerContext.defaultSpace.participants.size == 1) killMe
	}
	/** 
	 * Détermine l'agent qui a eu le token le moins de fois jusqu'ici
	 */
	def determineAgentToReceiveToken : UUID {
		var min = Collections.min(tokens.values)
		for (entry : tokens.entrySet) {
			if (entry.value == min) {
				return entry.key
			}
		}
	}
	/** 
	 * Envois du token à l'agent concerné
	 */
	def sendToken(id : UUID) {
		in(100) [
			agentResolving = id;
			wake(
				new TokenReceived,
				Scopes.addresses(innerContext.defaultSpace.getAddress(id))
			)

		]
	}
	/** 
	 * Le token a été relâché par l'agent qui l'avait
	 */
	on TokenReleased [occurrence.source.UUID == agentResolving] {
		tokenReleasedLock.lock
		if (occurrence.done) {
			tokens.remove(occurrence.source.UUID)
			agents.remove(occurrence.source.UUID)
		}

		var nb = tokens.get(occurrence.source.UUID)
		if (nb !== null) {
			nb++
			tokens.put(occurrence.source.UUID, nb)
		}
		if (tokens.size > 0) {
			sendToken(determineAgentToReceiveToken)
		}

		tokenReleasedLock.unlock
	}
	/** 
	 * L'agent est initialisé
	 */
	on ReadyToResolve {
		tokens.put(occurrence.source.UUID, 0);
		ecoTokens.put(occurrence.source.UUID, 0);
		if (tokens.size == innerContext.defaultSpace.participants.size - 1) {
			emit(new BlocReady)
			tokens.put(occurrence.source.UUID, 1);
			sendToken(occurrence.source.UUID);
		}
	}

	// Partie concernant l'éco-résolution
	def determineEcoAgent : UUID {
		var min = Collections.min(ecoTokens.values)
		for (entry : ecoTokens.entrySet) {
			if (entry.value == min) {
				return entry.key
			}
		}
	}

	def sendEcoToken(id : UUID) {
		if (id === null) {
			error("L'id est null : " + ecoTokens)
		} else {
			var nb = ecoTokens.get(id)
			nb++
			ecoTokens.replace(id, nb)
			wake(
				new EcoTokenReceived,
				Scopes.addresses(innerContext.defaultSpace.getAddress(id))
			)
		}
	}

	on EcoTokenReleased [!fromMe] {
		if (occurrence.done) {
			ecoTokens.remove(occurrence.source.UUID)
		} 
		if (occurrence.changed == true) {
//			emit(new EcoTokenReleased, Scopes.addresses(defaultSpace.getAddress(spawner)))
		} else {
			sendEcoToken(determineEcoAgent)
		}
	}

	on EcoTokenReceived [!fromMe] {
		sendEcoToken(determineEcoAgent)
	}

	on EcoValue {
		emit(new SolutionFoundInBloc => [
			solution = occurrence.value;
			x = occurrence.x;
			y = occurrence.y;
			definitive = false;
			tokenReleased = true;
		])
	}

	on ResetEcoValues [!fromMe] {
		wake(new ResetEcoValues)
	}
}

/** 
 * 
 */
package fr.utbm.sudoku

import fr.utbm.sudoku.controllers.GridController
import fr.utbm.sudoku.events.ColAgentSpawned
import fr.utbm.sudoku.events.ColInitialized
import fr.utbm.sudoku.events.Exit
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.RowAgentSpawned
import fr.utbm.sudoku.events.RowAndColInit
import fr.utbm.sudoku.events.RowAndColSpawned
import fr.utbm.sudoku.events.RowInitialized
import fr.utbm.sudoku.events.SolutionFoundInBloc
import fr.utbm.sudoku.events.SpawnRequired
import fr.utbm.sudoku.events.UpdateSudoku
import fr.utbm.sudoku.model.BlocAgent
import fr.utbm.sudoku.model.ColumnAgent
import fr.utbm.sudoku.model.ContextContainer
import fr.utbm.sudoku.model.RowAgent
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.OpenEventSpace
import java.util.ArrayList
import java.util.UUID

agent EnvAgent {

	uses Logging, ExternalContextAccess, DefaultContextInteractions, Behaviors, Lifecycle

	var app : SudokuApplication

	var controller : GridController

	val rowCtxIds = new ArrayList<ContextContainer>
	val colCtxIds = new ArrayList<ContextContainer>

	var openSpace : OpenEventSpace
	
	var rowInit = new Integer(0);
	var colInit = new Integer(0);

	on Initialize {
		if (occurrence.parameters.length >= 2) {
			this.app = occurrence.parameters.get(0) as SudokuApplication
			this.openSpace = occurrence.parameters.get(1) as OpenEventSpace
		}
		openSpace.register(asEventListener)
	}

	on SpawnRequired {		
		this.controller = occurrence.controller
		info("Spawn command required")	
		for(var i =0;i<9;i++){
			RowAgent.spawn(i, this.controller.sudoku.getRow(i))
			ColumnAgent.spawn(i, this.controller.sudoku.getColumn(i))
		}
	}
	
	on RowAndColSpawned {
		var blocs = new ArrayList<UUID>
		for (var i = 0; i < 9; i++) {
			for (var j = 0; j < 9; j++) {
				var startI = i - 2
				var startJ = j - 2
				if (startI % 3 === 0 && startJ % 3 === 0) {
					blocs.add(
						BlocAgent.spawn(startI, startJ, this.controller.sudoku.getBloc(startI, i, startJ, j), rowCtxIds,
							colCtxIds))
				}
			}
		}
		info("Region agents spawned")
	}

	on RowAgentSpawned {
		synchronized(rowCtxIds){
			rowCtxIds.add(occurrence.num,
				new ContextContainer(occurrence.num, occurrence.contextId, occurrence.^space, occurrence.Id))
			synchronized (colCtxIds) {
				if(colCtxIds.size == 9 && rowCtxIds.size == 9){
					wake(new RowAndColSpawned)
				}
			}
		}
	}

	on ColAgentSpawned {
		synchronized (colCtxIds) {
			colCtxIds.add(occurrence.num,
				new ContextContainer(occurrence.num, occurrence.contextId, occurrence.^space, occurrence.Id))
			synchronized (rowCtxIds) {
				if (colCtxIds.size == 9 && rowCtxIds.size == 9) {
					wake(new RowAndColSpawned)
				}
			}
		}
	}
	
	on RowInitialized{
		synchronized(rowInit){
			rowInit ++
			synchronized (colInit) {
				if (colInit.equals(9) && rowInit.equals(9)) {
					wake(new RowAndColInit)
				}
			}
		}
	}
	
	on ColInitialized {
		synchronized (colInit) {
			colInit++
			synchronized (rowInit) {
				if (colInit.equals(9) && rowInit.equals(9)) {
					wake(new RowAndColInit)
				}
			}
		}
	}
	
	on Resolve [!it.isFrom(ID)]{
		emit(new Resolve)
	}
	
	on RowAndColInit{
		controller.enableStart
	}
	
	on SolutionFoundInBloc {
		openSpace.emit(
			new UpdateSudoku => [solution = occurrence.solution; x = occurrence.x; y = occurrence.y]
		)
	}

	on Exit {
		killMe
	}

}

/** 
 * 
 */
package fr.utbm.sudoku.behaviors

import fr.utbm.sudoku.capacities.SudokuBaseCommunication
import fr.utbm.sudoku.capacities.SudokuCommunication
import fr.utbm.sudoku.events.AnswerForCandidate
import fr.utbm.sudoku.events.AskForCandidate
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.model.RegionTypeEnum
import fr.utbm.sudoku.model.ScanCommand
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.lang.core.Agent
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.List
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
behavior HiddenSingletonSeekingBehavior {

	uses DefaultContextInteractions, SudokuCommunication, ExternalContextAccess

	var resolving = true
	var scanning = false
	var candidates : ConcurrentLinkedQueue<Integer>
	var sudokuCommunicationSkill : SudokuBaseCommunication
	var scanQueue = new ConcurrentLinkedQueue<ScanCommand>
	var scanCommand : ScanCommand
	var scanCommandLock = new ReentrantLock

	new (a : Agent, c : ConcurrentLinkedQueue<Integer>, s : SudokuBaseCommunication) {
		super(a)
		this.candidates = c
		this.sudokuCommunicationSkill = s
	}

	on Initialize {
		setSkill(sudokuCommunicationSkill, SudokuCommunication)
	}

	on Resolve [resolving && candidates.size > 1 && !scanning] {
		scanning = true
		for (c : candidates) {
			for (type : RegionTypeEnum.values) {
				var scanCommand = new ScanCommand => [
					it.candidate = c;
					it.expectedAnswers = spaces.get(type).participants.size - 2
					it.type = type
				]
				scanQueue.add(scanCommand)
			}
		}
		scanNextRegion
	}

	on SolutionFound [!isFromMe] {
		var regions = determineRegion(occurrence)
		for (r : regions) {
			for (c : candidates) {
				if (c !== occurrence.solution) { // On vérifie quand même au cas où
					var scanCommand = new ScanCommand => [
						it.candidate = c;
						it.type = r;
						it.expectedAnswers = spaces.get(r).participants.size - 2
					]
					scanQueue.add(scanCommand)
				}
			}
		}
	}
	/** 
	 * L'agent reçoit une réponse à son AskForCandidate
	 * Si aucun agent d'un des holons partagés ne peut recevoir le candidat, alors on a une solution
	 */
	on AnswerForCandidate [resolving && !isFromMe && !scanCommand.hasAgentAnswered(occurrence.source.UUID)] {

		scanCommandLock.lock
		var result = scanCommand.addAnswer(occurrence.source.UUID, occurrence.answer)
		scanCommandLock.unlock
		
		if (result == -1) {
			// Scan terminé sans solution
			scanNextRegion
		} else if (result > 0) {
			// Scan terminé avec solution
			scanning = false
			resolving = false
			emitSolution(scanCommand.candidate)
		}

	}
	/** 
	 * L'agent reçoit une demande d'un autre agent pour s'avoir s'il peut acceuilir le candidat passé en paramètre
	 */
	on AskForCandidate [!isFrom(spaces.get(RegionTypeEnum.BLOC).getAddress(ID)) &&
		!isFrom(spaces.get(RegionTypeEnum.LIGNE).getAddress(ID)) &&
		!isFrom(spaces.get(RegionTypeEnum.COLONNE).getAddress(ID))] {

		val answerEvent = new AnswerForCandidate => [
			answer = candidates.contains(occurrence.value);
			value = new Integer(occurrence.value);
			x = getX;
			y = getY;
			type = occurrence.type;
		]
		answerEvent.source = spaces.get(occurrence.type).getAddress(ID)
		spaces.get(occurrence.type).emit(answerEvent, Scopes::addresses(occurrence.source))
	}

	def relaseToken {
		emit(new TokenReleased)
	}

	def scanNextRegion() {
		scanCommandLock.lock
		scanCommand = scanQueue.poll
		scanCommandLock.unlock
		var e = new AskForCandidate(scanCommand.candidate, scanCommand.type)
		if (scanCommand !== null) {
			e.emitToHolon(scanCommand.type)
		}
	}

	def determineRegion(e : SolutionFound) : List<RegionTypeEnum> {
		var regions = new ArrayList<RegionTypeEnum>
		if(e.x == x) regions.add(RegionTypeEnum.LIGNE)
		if(e.y == y) regions.add(RegionTypeEnum.COLONNE)
		if (Math.abs(e.x - x) < 3 && Math.abs(e.y - y) < 3) {
			regions.add(RegionTypeEnum.BLOC)
		}
		return regions
	}
}

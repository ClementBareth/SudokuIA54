/** 
 * 
 */
package fr.utbm.sudoku.behaviors

import fr.utbm.sudoku.capacities.SudokuBaseCommunication
import fr.utbm.sudoku.capacities.SudokuCommunication
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.StopResolve
import fr.utbm.sudoku.model.RegionTypeEnum
import io.sarl.core.Behaviors
import io.sarl.core.Initialize
import io.sarl.lang.core.Agent
import java.util.Set
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue

/** 
 * @author Cl√©ment Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
behavior NudeSingletonSeekingBehavior {
	uses SudokuCommunication, Behaviors
	
	var resolving = true
	var candidates : ConcurrentLinkedQueue<Integer>
	var communicationSkill : SudokuBaseCommunication
	var regionValues = new ConcurrentHashMap<RegionTypeEnum, Set<Integer>>

	new (a : Agent, c : ConcurrentLinkedQueue<Integer>, s : SudokuBaseCommunication,
		rv : ConcurrentHashMap<RegionTypeEnum, Set<Integer>>) {
		super(a)
		this.candidates = c
		this.communicationSkill = s
		this.regionValues = rv;
	}

	on Resolve [resolving]{
		seekSolution
	}

	on SolutionFound [resolving && !isFromMe] {
		seekSolution
	}
	
	on ReadyToResolve{
		seekSolution
	}

	on Initialize {
		setSkill(communicationSkill, SudokuCommunication)
	}
	
	def seekSolution() {
		if (resolving && candidates.size == 1) {
			resolving = false
			wake(new StopResolve)
			val c = candidates.poll
			for(v : RegionTypeEnum.values){
				regionValues.get(v).add(c)
			}
			emitToAllHolons(new SolutionFound => [solution = c; x = getX; y = getY])
		}
	}
	

}

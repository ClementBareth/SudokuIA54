/** 
 * 
 */
package fr.utbm.sudoku.behaviors

import fr.utbm.sudoku.capacities.SudokuBaseCommunication
import fr.utbm.sudoku.capacities.SudokuCommunication
import fr.utbm.sudoku.events.EcoValue
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.model.Configuration
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.lang.core.Agent
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
behavior EcoResolutionBehavior {

	uses SudokuCommunication, Logging, DefaultContextInteractions

	var private sudokuCommunicationSkill : SudokuBaseCommunication
	var private candidates : ConcurrentLinkedQueue<Integer>
	var private actualValue = new Integer(0)
	var agentsValues = new ConcurrentHashMap<UUID, Integer>
	var nbUnchanged = 0
	val maxNbUnchanged = 200000000
	var tokenReceivedSatisfiedLock = new ReentrantLock
	var config : Configuration
	var passedConfigs = new ArrayList<Configuration>

	on Initialize {
		setSkill(sudokuCommunicationSkill, SudokuCommunication)
		config = new Configuration(ID)
	}

	new(^agent : Agent, values : ConcurrentLinkedQueue<Integer>, s : SudokuBaseCommunication) {
		super(^agent)
		this.candidates = values
		this.sudokuCommunicationSkill = s
	}

	on EcoValue [!isFromMe] {
		config.update(occurrence.source.UUID,occurrence.value)
		agentsValues.put(occurrence.source.UUID, occurrence.value)
	}
	
	on TokenReleased [!fromMe && occurrence.done == true] {
		var value = agentsValues.get(occurrence.source.UUID)
		if(value !== null) candidates.remove(value)
	}

	// Si l'agent n'a qu'un seul candidat, c'est forcément la solution.
	on TokenReceived [candidates.size == 1] {
		changeValue(candidates.element)
		emitToAllHolons(new SolutionFound => [solution = candidates.element; x = getX; y = getY])
		emit(new TokenReleased => [done = true])
	}

	on TokenReceived [candidates.size == 0] {
		emit(new TokenReleased => [done = true])
	}

	// Chaque agent recevra une fois le token pour intialiser sa valeur
	on TokenReceived [!satisfied && candidates.size > 1] {
//		val cand2 = new ArrayList<Integer>(candidates)
// 		cand2.remove(actualValue)
//		var newValue = false
//		for (c : cand2) {
//			var newConf = config.image
//			newConf.update(ID,c)
//			if(!passedConfigs.contains(newConf)){
//				newValue = true
//				changeValue(c)
//				break;
//			}
//		}
//		if(!newValue) error("No new configurations possible")
		val cand = valuesWithLessOccurrences
		info(cand)
		if (cand.size > 0) {
			changeValue(pollRandomValueFromList(cand))
		} else {
			error("No candidates availables")
		}
		emit(new TokenReleased)
	}

	on TokenReceived [satisfied] {
		tokenReceivedSatisfiedLock.lock
		nbUnchanged++
		if (nbUnchanged > maxNbUnchanged) {
			emitToAllHolons(new SolutionFound => [solution = candidates.element; x = getX; y = getY])
			emit(new TokenReleased => [done = true])
		} else {
			emit(new TokenReleased)
			
		}
		tokenReceivedSatisfiedLock.unlock
	}

	def private satisfied : boolean {
		return (!actualValue.equals(0) && !agentsValues.containsValue(actualValue))
//		return (!config.myValue.equals(0) && config.isInConflict)
	}

	def getValuesWithLessOccurrences : List<Integer> {
		var occurrences = occurrencesMap
		occurrences.remove(actualValue)
		var min = Collections.min(occurrences.values)
		var list = new ArrayList<Integer>
		for (e : occurrences.entrySet) {
			if (e.value.equals(min)) {
				list.add(e.key)
			}
		}
		return list;
	}

	def changeValue(value : int) {
//		info(actualValue + " => " + value)
		nbUnchanged = 0
		actualValue = value
		passedConfigs.add(config.image)
		config.update(ID, value)
		emitToAllHolons(new EcoValue => [x = getX; y = getY; value = actualValue])
	}

	def private countOccurrences(candidate : Integer) : Integer {
		return Collections.frequency(agentsValues.values, candidate)
	}

	def private getOccurrencesMap : Map<Integer, Integer> {
		var map = new HashMap<Integer, Integer>
		for (c : candidates) {
			map.put(c, c.countOccurrences)
		}
		return map
	}

	def private pollRandomValueFromList(list : List<Integer>) {
		Collections.shuffle(list)
		var value = list.get(0)
		return value
	}
}

/** 
 * 
 */
package fr.utbm.sudoku.behaviors

import fr.utbm.sudoku.capacities.SudokuBaseCommunication
import fr.utbm.sudoku.capacities.SudokuCommunication
import fr.utbm.sudoku.events.EcoTokenReceived
import fr.utbm.sudoku.events.EcoTokenReleased
import fr.utbm.sudoku.events.EcoValue
import fr.utbm.sudoku.events.ResetEcoValues
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.model.RegionTypeEnum
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.lang.core.Agent
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
behavior EcoResolutionBehavior {

	uses SudokuCommunication, Logging, DefaultContextInteractions

	var private sudokuCommunicationSkill : SudokuBaseCommunication
	var private candidates : ConcurrentLinkedQueue<Integer>
	var private actualValue = new Integer(0)
	var agentsValues = new ConcurrentHashMap<UUID, Integer>
	var blocValues = new ConcurrentHashMap<UUID, Integer>

	var nbUnchanged = 0
	val maxNbUnchanged = 30000
	var tokenReceivedSatisfiedLock = new ReentrantLock

	on Initialize {
		setSkill(sudokuCommunicationSkill, SudokuCommunication)
	}

	new(^agent : Agent, values : ConcurrentLinkedQueue<Integer>, s : SudokuBaseCommunication) {
		super(^agent)
		this.candidates = values
		this.sudokuCommunicationSkill = s
	}

	on EcoValue [!isFromMe] {
		agentsValues.put(occurrence.source.UUID, occurrence.value)
		var regions = determineRegion(occurrence.x, occurrence.y)

		if (regions.contains(RegionTypeEnum.BLOC)) {
			blocValues.put(occurrence.source.UUID, occurrence.value)
		}
	}

	on EcoTokenReleased [!fromMe && occurrence.done == true] {
		var value = agentsValues.get(occurrence.source.UUID)
		if(value !== null) candidates.remove(value)
	}

	// Si l'agent n'a qu'un seul candidat, c'est forcément la solution.
	on EcoTokenReceived [candidates.size == 1] {
		changeValue(candidates.element, true)
		emitToAllHolons(new SolutionFound => [solution = candidates.element; x = getX; y = getY])
		emit(new EcoTokenReleased => [done = true; changed = true])
	}

	on EcoTokenReceived [candidates.size == 0] {
		error("Agent should not have received token")
		emit(new EcoTokenReleased => [done = true; changed = false])
	}
	
	on ResetEcoValues{
		changeValue(0, false)
	}

	// Chaque agent recevra une fois le token pour intialiser sa valeur
	on EcoTokenReceived [!satisfied && candidates.size > 1] {
//		 val cand = new ArrayList(candidates)
//		 cand.remove(actualValue)
		val cand = valuesWithLessOccurrences
		if (cand.size > 0) {
			changeValue(pollRandomValueFromList(cand), true)
			emit(new EcoTokenReleased => [done = false; changed = true])
		} else {
			emit(new EcoTokenReleased => [done = false; changed = false])
			error("No candidates availables")
		}
	}

	on EcoTokenReceived [satisfied] {
		 emit(new EcoTokenReleased => [done = false; changed = false])
		
//		tokenReceivedSatisfiedLock.lock
//		nbUnchanged++
//		if (nbUnchanged > maxNbUnchanged) {
//			emitToAllHolons(new SolutionFound => [solution = candidates.element; x = getX; y = getY])
//			emit(new EcoTokenReleased => [done = true; changed = false])
//		} else {
//			emit(new EcoTokenReleased => [done = false; changed = false])
//
//		}
//		tokenReceivedSatisfiedLock.unlock
	}

	def private satisfied : boolean {
		return (!actualValue.equals(0) && !agentsValues.containsValue(actualValue))
	}

	def getValuesWithLessOccurrences : List<Integer> {
		var occurrences = occurrencesMap
		occurrences.remove(actualValue)
		var min = Collections.min(occurrences.values)
		var list = new ArrayList<Integer>
		for (e : occurrences.entrySet) {
			if (e.value.equals(min)) {
				list.add(e.key)
			}
		}
		return list;
	}

	def changeValue(value : int, tokenRealease : boolean) {
		nbUnchanged = 0
		actualValue = value
		// emit(new EcoValue => [x = getX; y = getY; value = actualValue])
		emitToAllHolons(new EcoValue => [x = getX; y = getY; value = actualValue;  token = tokenRealease])
	}

	def private countOccurrences(candidate : Integer) : Integer {
		var freq = Collections.frequency(agentsValues.values, candidate)
		if(blocValues.containsValue(candidate)) return freq * 10 
		if(actualValue.equals(candidate)) return freq * 20
		else return freq;
	}

	def private getOccurrencesMap : Map<Integer, Integer> {
		var map = new HashMap<Integer, Integer>
		for (c : candidates) {
			map.put(c, c.countOccurrences)
		}
		return map
	}

	def private pollRandomValueFromList(list : List<Integer>) {
		Collections.shuffle(list)
		var value = list.get(0)
		return value
	}
}

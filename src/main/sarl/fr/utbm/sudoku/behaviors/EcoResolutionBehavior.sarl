/** 
 * 
 */
package fr.utbm.sudoku.behaviors

import fr.utbm.sudoku.capacities.SudokuBaseCommunication
import fr.utbm.sudoku.capacities.SudokuCommunication
import fr.utbm.sudoku.events.Aggression
import fr.utbm.sudoku.events.EcoValue
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.model.EcoAgentRepresentation
import fr.utbm.sudoku.model.RegionTypeEnum
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue

/** 
 * @author Cl√©ment Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
behavior EcoResolutionBehavior {

	uses SudokuCommunication, Logging, DefaultContextInteractions

	var private sudokuCommunicationSkill : SudokuBaseCommunication
	var private candidates : ConcurrentLinkedQueue<Integer>
	var private actualValue = new Integer(0)
	var agentsValues = new ConcurrentHashMap<EcoAgentRepresentation, Integer>

	on Initialize {
		setSkill(sudokuCommunicationSkill, SudokuCommunication)
	}

	new(^agent : Agent, values : ConcurrentLinkedQueue<Integer>, s : SudokuBaseCommunication) {
		super(^agent)
		this.candidates = values
		this.sudokuCommunicationSkill = s
	}

	on EcoValue {
		// var regions = determineRegion(occurrence.x, occurrence.y);
		// var repres = new EcoAgentRepresentation(occurrence.source.UUID, regions)
		// agentsValues.put(repres, occurrence.value)
	}

	on ReadyToResolve {
		// if (candidates.size > 0) {
		// actualValue = candidates.element
		// emitToHolon(new EcoValue => [it.value = actualValue; it.x = getX; it.y = getY], RegionTypeEnum.COLONNE)
		// }
	}

//	on Aggression [!isMe(occurrence.source.UUID)] {
//		var regions = determineRegion(occurrence.x, occurrence.y);
//		var repres = new EcoAgentRepresentation(occurrence.source.UUID, regions)
//		agentsValues.put(repres, occurrence.value)
//		val cand = valuesWithLessOccurrences
//		cand.removeAll(#[actualValue, occurrence.value])
//		if (cand.size > 0) {
//			actualValue = pollRandomValueFromList(cand)
//			agression
//		}
//	}

	on TokenReceived [candidates.size == 1] {
		actualValue = candidates.element;
		agression
		emit(new TokenReleased => [done = true])
	}
	

	on TokenReceived [!satisfied] {
		// Aggression
		val cand = new ArrayList(candidates)
		// valuesWithLessOccurrences
		cand.removeAll(#[
			actualValue
		])
		if (cand.size > 0) {
			actualValue = pollRandomValueFromList(cand)
			agression
		}
		emit(new TokenReleased)
	}

	on TokenReceived [satisfied] {
		emit(new TokenReleased)
	}

	def private satisfied : boolean {
		return (!actualValue.equals(0) && !agentsValues.values.contains(actualValue)) || candidates.size == 1
	}

	def private getValuesWithLessOccurrences : List<Integer> {
		var occurrences = occurrencesMap
		var min = Collections.min(occurrences.values)
		var list = new ArrayList<Integer>
		for (e : occurrences.entrySet) {
			if (e.value.equals(min)) {
				list.add(e.key)
			}
		}
		return list;
	}

	def agression() {
		var listBloc = new ArrayList<Address>
		var listCol = new ArrayList<Address>
		var listRow = new ArrayList<Address>

		for (entry : agentsValues.entrySet) {
			if (entry.value.equals(actualValue)) {
				var type = entry.key.regions.get(0)
				switch (type) {
					case BLOC:
						listBloc.add(
							spaces.get(RegionTypeEnum.BLOC).getAddress(entry.key.id)
						)
					case COLONNE:
						listCol.add(
							spaces.get(RegionTypeEnum.COLONNE).getAddress(entry.key.id)
						)
					case LIGNE:
						listRow.add(
							spaces.get(RegionTypeEnum.LIGNE).getAddress(entry.key.id)
						)
				}
			}
		}

		// info("Blocs : " + listBloc)
		// info("Ligne : " + listRow)
		// info("Colonne : "+ listCol)
		var agressionEvent = new Aggression => [it.value = actualValue; x = getX; y = getY]
		if(listBloc.size > 1) agressionEvent.emitToHolon(RegionTypeEnum.BLOC, Scopes.addresses(listBloc))
		if(listBloc.size > 1) agressionEvent.emitToHolon(RegionTypeEnum.LIGNE, Scopes.addresses(listRow))
		if(listBloc.size > 1) agressionEvent.emitToHolon(RegionTypeEnum.COLONNE, Scopes.addresses(listCol))

		if (agentsValues.size == 0) {
			emitToAllHolons(new Aggression => [it.value = actualValue; x = getX; y = getY])
		}

	}

	def private countOccurrences(candidate : Integer) : Integer {
		return Collections.frequency(agentsValues.values, candidate)
	}

	def private getOccurrencesMap : Map<Integer, Integer> {
		var map = new HashMap<Integer, Integer>
		for (c : candidates) {
			map.put(c, c.countOccurrences)
		}
		return map
	}

	def private pollRandomValueFromList(list : List<Integer>) {
		Collections.shuffle(list)
		var value = list.get(0)
		list.remove(value)
		return value
	}
}

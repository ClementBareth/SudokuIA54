/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.events.PositionX
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.RowAgentSpawned
import fr.utbm.sudoku.events.RowInitialized
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberLeft
import java.util.HashMap
import java.util.List
import java.util.UUID

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent RowAgent {
	uses Logging, InnerContextAccess, DefaultContextInteractions, Behaviors, Lifecycle

	var rowNum : Integer
	var rowValues : List<Integer>
	var agents = new HashMap<Integer, UUID>

	on Initialize {

		if (occurrence.parameters.length >= 2) {
			this.rowNum = occurrence.parameters.get(0) as Integer
			this.rowValues = occurrence.parameters.get(1) as List<Integer>
			loggingName = "RowAgent n° " + rowNum
		}
		emit(new RowAgentSpawned => [
			num = rowNum;
			contextId = innerContext.ID;
			^space = innerContext.defaultSpace;
			Id = ID;
		])
	}

	def countZeros : Integer {
		var j = 0;
		for (i : rowValues) {
			if (i === null || i == 0) {
				j++
			}
		}
		return j;
	}

	on Destroy {
		info("The agent was stopped.")
	}

	on PositionX {
		synchronized (agents) {
			agents.put(occurrence.pos, occurrence.id)
			if (agents.size==countZeros){
				emit (new RowInitialized => [id = ID])
			}
		}
	}

	on Resolve [!it.isFrom(ID)] {
		wake(new Values => [values = rowValues])
	}

	on MemberLeft {
		if(innerContext.defaultSpace.participants.size == 1) killMe
	}
}

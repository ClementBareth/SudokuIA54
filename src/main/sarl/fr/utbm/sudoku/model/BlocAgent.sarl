/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.behaviors.RegionAgentBehavior
import fr.utbm.sudoku.events.Algos
import fr.utbm.sudoku.events.Exit
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.SolutionFoundInBloc
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberLeft
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.UUID
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent BlocAgent {
	uses Logging, InnerContextAccess, Lifecycle, Behaviors, DefaultContextInteractions
	
	var startRow : Integer
	var startCol : Integer
	var blocValues : List<Integer>
	var rowCtxIds : List<UUID>
	var colCtxIds : List<UUID>
	val agents = new HashMap<Integer, UUID>
	var valuesLock = new ReentrantLock
	val regionAgentBehavior = new RegionAgentBehavior(this)
	

	on Initialize {
		registerBehavior(regionAgentBehavior)
		
		if (occurrence.parameters.length >= 5) {
			this.startRow = occurrence.parameters.get(0) as Integer
			this.startCol = occurrence.parameters.get(1) as Integer
			this.blocValues = occurrence.parameters.get(2) as List<Integer>
			this.rowCtxIds = occurrence.parameters.get(3) as List<UUID>
			this.colCtxIds = occurrence.parameters.get(4) as List<UUID>
			loggingName = "Bloc n°(" + startRow + ","+startCol+")"
		}
		for (var i = 0; i < 9; i++) {
			if (blocValues.get(i) === null || blocValues.get(i) == 0) {
				var row = startRow + i / 3 as Integer
				var col = startCol + i % 3
				agents.put(i, CellAgent.spawnInContext(innerContext, rowCtxIds.get(row), colCtxIds.get(col),row,col))
			}
		}
	}

	on Resolve [!it.isFrom(ID)] {
		wake(new Values => [values = new ArrayList<Integer>(blocValues)])
		wake(new Algos => [algos = occurrence.algos])	
	}
	
	on SolutionFound{
		valuesLock.lock
		if(!blocValues.contains(occurrence.solution)){
			blocValues.add(occurrence.solution)
			valuesLock.unlock
			emit(new SolutionFoundInBloc => [solution = occurrence.solution; x = occurrence.x; y = occurrence.y])
		} else {
			valuesLock.unlock
		}
	}
	
	on Exit{
		wake(new Exit)
	}

	on MemberLeft {
		if(innerContext.defaultSpace.participants.size == 1) killMe
	}
	
	on Destroy{
		unregisterBehavior(regionAgentBehavior)
	}
}
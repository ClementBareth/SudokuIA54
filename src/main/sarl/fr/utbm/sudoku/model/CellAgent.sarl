/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.events.AnswerForCandidate
import fr.utbm.sudoku.events.AskForCandidate
import fr.utbm.sudoku.events.PositionX
import fr.utbm.sudoku.events.PositionY
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SendMessages
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.UUID
import java.util.concurrent.locks.ReentrantLock
/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent CellAgent {
	uses Logging, ExternalContextAccess, DefaultContextInteractions, SudokuMaths, Behaviors

	var x : Integer
	var y : Integer
	var rowCtxId : ContextContainer
	var colCtxId : ContextContainer
	var rowJoined : boolean
	var colJoined : boolean
	var nbValuesReceived = new Integer(0)
	var values = new HashSet<Integer>
	var valuesLock = new ReentrantLock
	var waitingAnswers = false
	var resolving = true
	/** 
	 * Clef : ID du holon
	 * Valeur : nombres de réponses reçues de ce holon
	 */
	var answersReceived = new HashMap<RegionTypeEnum, Integer>
	var answersFalseReceived = new HashMap<RegionTypeEnum, Integer>
	var spaces = new HashMap<RegionTypeEnum, EventSpace>
	
	var candidateInTest : Integer
	var candidateInTestLock = new ReentrantLock
	
	var nbValuesReceivedLock = new ReentrantLock
	var answersReceivedLock = new ReentrantLock
	var answersFalseReceivedLock = new ReentrantLock
	var candidatesLock = new ReentrantLock
	var resolvingLock = new ReentrantLock
	var candidates = new ArrayList<Integer>
	var candidatesAskedLock = new ReentrantLock
	var candidatesAsked = new ArrayList<Integer>
	val sendAnswerLock = new ReentrantLock

	val l1 = new ReentrantLock

	val emitLock = new ReentrantLock

	on Initialize {
		if (occurrence.parameters.length >= 4) {
			rowCtxId = occurrence.parameters.get(0) as ContextContainer
			colCtxId = occurrence.parameters.get(1) as ContextContainer
			x = occurrence.parameters.get(2) as Integer // row
			y = occurrence.parameters.get(3) as Integer // col
			loggingName = "Cell n° (" + x + "," + y + ")"
			join(rowCtxId.contextId, rowCtxId.^space.spaceID.ID)
			join(colCtxId.contextId, colCtxId.^space.spaceID.ID)
		}
		answersReceived.put(RegionTypeEnum.BLOC, 0)
		answersReceived.put(RegionTypeEnum.COLONNE, 0)
		answersReceived.put(RegionTypeEnum.LIGNE, 0)

		answersFalseReceived.put(RegionTypeEnum.BLOC, 0)
		answersFalseReceived.put(RegionTypeEnum.LIGNE, 0)
		answersFalseReceived.put(RegionTypeEnum.COLONNE, 0)

		spaces.put(RegionTypeEnum.BLOC, defaultSpace)
		spaces.put(RegionTypeEnum.LIGNE, rowCtxId.^space)
		spaces.put(RegionTypeEnum.COLONNE, colCtxId.^space)

		setSkill(new SudokuMathsBaseSkill(values), SudokuMaths)
		wake(new SendMessages)
	}

	on ContextJoined {
		if (occurrence.holonContextID.equals(rowCtxId.contextId)) {
			rowJoined = true
			rowCtxId.^space.emit(
				new PositionX(y, getID),
				Scopes.addresses(rowCtxId.^space.getAddress(rowCtxId.id))
			)
		}
		if (occurrence.holonContextID.equals(colCtxId.contextId)) {
			colJoined = true
			colCtxId.^space.emit(
				new PositionY(x, getID),
				Scopes.addresses(colCtxId.^space.getAddress(colCtxId.id))
			)
		}
	}

	on TokenReceived {
		// resolving = true
		wake(new Resolve)
	}

	on Values {
		nbValuesReceivedLock.lock
		values.addAll(occurrence.values)
		nbValuesReceived++
		if (nbValuesReceived == 3) {
			nbValuesReceivedLock.unlock
			emit(new ReadyToResolve)
		} else {
			nbValuesReceivedLock.unlock
		}
	}
	/** 
	 * L'agent commence la résolution du sudoku
	 */
	on Resolve {
		var hasAtLeasteOneCandidate = false
		var candidate : Integer = null
		var isResolving = true;

		resolvingLock.lock
		isResolving = resolving
		resolvingLock.unlock

		if (isResolving) {
			candidatesLock.lock
			candidates = evaluateCandidates
			if (candidates.size == 1) {
				candidate = candidates.get(0)
			} else if (candidates.size > 1) {
				hasAtLeasteOneCandidate = true
			}
			candidatesLock.unlock

			if (candidate !== null) {
				var c = candidate
				// S'il reste un seul candidat, on émet une solution puis on se suicide
				emitSolution(c)
			} else if (hasAtLeasteOneCandidate) {
				// Sinon s'il y a plus d'un candidat on va essayer de trouver ceux pour lesquel aucune autre solution n'est possible
				nextCandidateToTest
				if (candidateInTest !== null) {
					// waitingAnswers = true
					emit(new AskForCandidate => [
						value = candidateInTest;
						type = RegionTypeEnum.BLOC
					])
				}
			}
		}
	}
	/** 
	 * L'agent reçoit une réponse à son AskForCandidate
	 * Si aucun agent d'un des holons partagés ne peut recevoir le candidat, alors on a une solution
	 */
	on AnswerForCandidate {

//		info("Answer received from ("+occurrence.x+","+occurrence.y+" : "+occurrence.value+") in "+occurrence.type)

		var solutionFound = false
		var type = occurrence.type
		var ^space = spaces.get(type)

		answersReceivedLock.lock
		var nbAnswers = answersReceived.get(type)
		nbAnswers++
		answersReceived.put(type, nbAnswers);
		answersReceivedLock.unlock
		
		if (occurrence.answer == false) {
//			 info(type +" : "+occurrence.value + " can't go in (" + occurrence.x + "," + occurrence.y + ")")
			answersFalseReceivedLock.lock
			var nbAnswersFalse = answersFalseReceived.get(type)
			nbAnswersFalse++
			answersFalseReceived.put(type, nbAnswersFalse);
			answersFalseReceivedLock.unlock
			if (nbAnswersFalse == ^space.participants.size - 2) {
				solutionFound = true
			}
		} else {
//			 info(type + " : " + occurrence.value + " can go in (" + occurrence.x + "," + occurrence.y + ")")
		}
		if (solutionFound) {
			// info("Nb participants in region : " + (^space.participants.size - 2))
			info(type+" : Solution 2 : "+occurrence.value)
			emitSolution(occurrence.value)
		} else {
			answersReceivedLock.lock
			var nb = answersReceived.get(type)
			var p = ^space.participants.size - 2			
			info(type + " : answers = " + nb + " / " + p)
			answersReceivedLock.unlock
			
			if (nb == p) {
				// FIXME Plusieurs threads accèdent à cette section en même temps ou a peu de chose près
				candidateInTestLock.lock
				switch (type) {
					case BLOC: {
						colCtxId.^space.emit(new AskForCandidate => [
							value = candidateInTest;
							it.type = RegionTypeEnum.COLONNE
						])
					}
					case COLONNE: {
						info("Recherche de " + candidateInTest)
						rowCtxId.^space.emit(new AskForCandidate => [
							value = candidateInTest;
							it.type = RegionTypeEnum.LIGNE
						])
					}
					case LIGNE: {
//						if (nextCandidateToTest !== null) {
//							emit(new AskForCandidate => [
//								value = candidateInTest;
//								it.type = RegionTypeEnum.BLOC
//							])
//						} else {
							relaseToken
//						}
					}
				}
				candidateInTestLock.unlock
			}
			// if(nb > p){ info ("CA DEPASSE")}
		}
		
	}
	/** 
	 * Une solution a été trouvée dans un holon de l'agent
	 */
	on SolutionFound [!occurrence.isFromMe] {
		valuesLock.lock
		if (!values.contains(occurrence.solution)) {
			values.add(occurrence.solution)
			valuesLock.unlock
			// waitingAnswers = false
			clearAnswers

			candidatesLock.lock
			candidates = evaluateCandidates
			if (candidates.size !== 0) {
				candidateInTest = candidates.get(0)
			}
			candidatesLock.unlock

			wake(new Resolve)
		} else {
			valuesLock.unlock
		}
	}
	/** 
	 * L'agent reçoit une demande d'un autre agent pour s'avoir s'il peut acceuilir le candidat passé en paramètre
	 */
	on AskForCandidate [!isFromMe] {
		candidatesLock.lock
		candidates = evaluateCandidates
		// info(occurrence)
		val answerEvent = new AnswerForCandidate => [
			answer = candidates.contains(occurrence.value);
			value = new Integer(occurrence.value);
			x = this.x;
			y = this.y;
			type = occurrence.type;
		]
		candidatesLock.unlock
		sendAnswerLock.lock
		spaces.get(occurrence.type).emit(answerEvent, Scopes::addresses(occurrence.source))
		sendAnswerLock.unlock
	}
	/** 
	 * Relâche le token et se met en attente
	 */
	def relaseToken {
		emit(new TokenReleased)
	}
	/** 
	 * Calcul la différence entre les candidats potentiels et les candidats qui ont été sujets d'un AskForCandidate
	 */
	def nextCandidateToTest : Integer {
		candidatesAskedLock.lock
		for (candidate : candidates) {
			if (!candidatesAsked.contains(candidate)) {
				candidatesAsked.add(candidate)
				this.candidateInTest = candidate
				candidatesAskedLock.unlock
				clearAnswers
				return candidate
			}
		}
		candidatesAskedLock.unlock
		return null
	}

	def clearAnswers {
		for (id : answersReceived.keySet) {
			answersReceivedLock.lock
			answersReceived.put(id, 0)
			answersReceivedLock.unlock
			answersFalseReceivedLock.lock
			answersFalseReceived.put(id, 0)
			answersFalseReceivedLock.unlock
		}
		waitingAnswers = false
	}

	def emitSolution(v : Integer) {
		// info("Solution has been found : " + v)
		resolvingLock.lock
		resolving = false
		resolvingLock.unlock
		values.add(v)
		emitToAllHolons(new SolutionFound => [solution = v; x = this.x; y = this.y])
		relaseToken
		// killMe
	}

	def emitToAllHolons(e : Event) {

		emitLock.lock
		emit(e)
		emitLock.unlock

		emitLock.lock
		rowCtxId.^space.emit(e)
		emitLock.unlock

		emitLock.lock
		colCtxId.^space.emit(e)
		emitLock.unlock

	}
	

}

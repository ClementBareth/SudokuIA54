/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.events.AnswerForCandidate
import fr.utbm.sudoku.events.AskForCandidate
import fr.utbm.sudoku.events.PositionX
import fr.utbm.sudoku.events.PositionY
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SendMessages
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent CellAgent {
	uses Logging, ExternalContextAccess, DefaultContextInteractions, SudokuMaths, Behaviors

	var x : Integer
	var y : Integer
	var rowCtxId : ContextContainer
	var colCtxId : ContextContainer
	var rowJoined : boolean
	var colJoined : boolean
	var nbValuesReceived = new Integer(0)
	var values = new HashSet<Integer>
	var valuesLock = new ReentrantLock
	var waitingAnswers = false
	var resolving = true
	/**
	 * Clef : ID du holon
	 * Valeur : nombres de réponses reçues de ce holon
	 */
	var answersReceived = new HashMap<UUID, Integer>
	var answersFalseReceived = new HashMap<UUID, Integer>
	var spaces = new HashMap<UUID, EventSpace>
	var candidateInTest : Integer
	var nbValuesReceivedLock = new ReentrantLock
	var answersReceivedLock = new ReentrantLock
	var answersFalseReceivedLock = new ReentrantLock
	var candidatesLock = new ReentrantLock
	var resolvingLock = new ReentrantLock
	var candidates = new ArrayList<Integer>
	var candidatesAskedLock = new ReentrantLock
	var candidatesAsked = new ArrayList<Integer>
	val sendAnswerLock = new ReentrantLock

	on Initialize {
		if (occurrence.parameters.length >= 4) {
			rowCtxId = occurrence.parameters.get(0) as ContextContainer
			colCtxId = occurrence.parameters.get(1) as ContextContainer
			x = occurrence.parameters.get(2) as Integer // row
			y = occurrence.parameters.get(3) as Integer // col
			loggingName = "Cell n° (" + x + "," + y + ")"
			join(rowCtxId.contextId, rowCtxId.^space.spaceID.ID)
			join(colCtxId.contextId, colCtxId.^space.spaceID.ID)
		}
		answersReceived.put(defaultContext.ID, 0)
		answersReceived.put(rowCtxId.id, 0)
		answersReceived.put(colCtxId.id, 0)

		answersFalseReceived.put(defaultContext.ID, 0)
		answersFalseReceived.put(rowCtxId.id, 0)
		answersFalseReceived.put(colCtxId.id, 0)

		spaces.put(defaultContext.ID, defaultSpace)
		spaces.put(rowCtxId.id, rowCtxId.^space)
		spaces.put(colCtxId.id, colCtxId.^space)

		setSkill(new SudokuMathsBaseSkill(values), SudokuMaths)
		wake (new SendMessages)
	}

	on ContextJoined {
		if (occurrence.holonContextID.equals(rowCtxId.contextId)) {
			rowJoined = true
			rowCtxId.^space.emit(
				new PositionX(y, getID),
				Scopes.addresses(rowCtxId.^space.getAddress(rowCtxId.id))
			)
		}
		if (occurrence.holonContextID.equals(colCtxId.contextId)) {
			colJoined = true
			colCtxId.^space.emit(
				new PositionY(x, getID),
				Scopes.addresses(colCtxId.^space.getAddress(colCtxId.id))
			)
		}
	}

	on TokenReceived {
		resolving = true
		wake(new Resolve)
	}

	on Values {
		nbValuesReceivedLock.lock
		values.addAll(occurrence.values)
		nbValuesReceived++
		if (nbValuesReceived == 3) {
			nbValuesReceivedLock.unlock
			emit(new ReadyToResolve)
		} else {
			nbValuesReceivedLock.unlock
		}
	}
	/** 
	 * L'agent commence la résolution du sudoku
	 */
	on Resolve {
		var hasAtLeasteOneCandidate = false
		var candidate : Integer = null
		var isResolving = true;

		resolvingLock.lock
		isResolving = resolving
		resolvingLock.unlock

		if (isResolving) {
			candidatesLock.lock
			candidates = evaluateCandidates
			if (candidates.size == 1) {
				candidate = candidates.get(0)
			} else if (candidates.size > 1) {
				hasAtLeasteOneCandidate = true
			}
			candidatesLock.unlock

			if (candidate !== null) {
				var c = candidate
				// S'il reste un seul candidat, on émet une solution puis on se suicide
				emitSolution(c)
			} 
			else if (hasAtLeasteOneCandidate && waitingAnswers==false) {
				// Sinon s'il y a plus d'un candidat on va essayer de trouver ceux pour lesquel aucune autre solution n'est possible
				nextCandidateToTest
				if (candidateInTest !== null) {
					waitingAnswers = true									
					emit(new AskForCandidate => [value = candidateInTest])				
					info("Waiting for other agents to answer ... ")			
				}			
			}
		}
	}
	/** 
	 * L'agent reçoit une réponse à son AskForCandidate
	 * Si aucun agent d'un des holons partagés ne peut recevoir le candidat, alors on a une solution
	 */
	on AnswerForCandidate {
		var ctxId : UUID
		var ^space : EventSpace
		var solutionFound = false
		var type : String

		if (occurrence.isInDefaultSpace) {
			type = "Bloc"
			ctxId = defaultContext.ID
			^space = defaultSpace
		} else if (occurrence.isInSpace(rowCtxId.^space)) {
			type = "Ligne"
			ctxId = rowCtxId.id
			^space = rowCtxId.^space
		} else if (occurrence.isInSpace(colCtxId.^space)) {
			type = "Colonne"
			ctxId = colCtxId.id
			^space = colCtxId.^space
		}
		
		answersReceivedLock.lock
		var nbAnswers = answersReceived.get(ctxId)
		nbAnswers++
		answersReceived.put(ctxId, nbAnswers);
		answersReceivedLock.unlock

		var isResolving = true;

		resolvingLock.lock
		isResolving = resolving
		resolvingLock.unlock

		if (isResolving) {
			if (occurrence.answer == false) {
				answersFalseReceivedLock.lock
				var nbAnswersFalse = answersFalseReceived.get(ctxId)		
				nbAnswersFalse++
				answersFalseReceived.put(ctxId, nbAnswersFalse);
				answersFalseReceivedLock.unlock
				if (nbAnswersFalse == ^space.participants.size - 2) {
					solutionFound = true
				}			
			}
			if (solutionFound) {
				emitSolution(occurrence.value)
			} else {
				var nb = answersReceived.get(ctxId)
				var p = ^space.participants.size - 2
				
				if (nb == p) {
					info("Search for "+candidateInTest+" in "+type+" is over")
					switch(type){
						case "Bloc": {
							colCtxId.^space.emit(new AskForCandidate => [value = candidateInTest])
							}							
						case "Colonne": {
							rowCtxId.^space.emit(new AskForCandidate => [value = candidateInTest]) 						
							}
						case "Ligne": {
							info("Passe au candidat suivant")						
							if (nextCandidateToTest !== null){
								waitingAnswers = true									
								emit(new AskForCandidate => [value = candidateInTest])								
							} else {
								info("Pas de candidats suivants")
								relaseToken
							}
						}
					}
				}
			}
		}	
	}
	/** 
	 * Une solution a été trouvée dans un holon de l'agent
	 */
	on SolutionFound [!occurrence.isFromMe] {
		valuesLock.lock
		if (!values.contains(occurrence.solution)) {
			values.add(occurrence.solution)
			valuesLock.unlock
			waitingAnswers = false
			clearAnswers
			candidatesLock.lock
			candidates = evaluateCandidates
			if(candidates.size !== 0){
				candidateInTest = candidates.get(0)
			}
			candidatesLock.unlock
			wake(new Resolve)
		} else {
			valuesLock.unlock
		}
	}
	/** 
	 * L'agent reçoit une demande d'un autre agent pour s'avoir s'il peut acceuilir le candidat passé en paramètre
	 */
	on AskForCandidate [!isFromMe] {
		candidatesLock.lock
		candidates = evaluateCandidates
		val answerEvent = new AnswerForCandidate => [
			answer = candidates.contains(occurrence.value);
			value = new Integer(occurrence.value)
		]
		candidatesLock.unlock
		sendAnswerLock.lock
		if (occurrence.isInDefaultSpace) {
			emit(answerEvent, Scopes::addresses(occurrence.source))
		} else if (occurrence.isInSpace(rowCtxId.^space)) {
			rowCtxId.^space.emit(answerEvent, Scopes::addresses(occurrence.source))
		} else if (occurrence.isInSpace(colCtxId.^space)) {
			colCtxId.^space.emit(answerEvent, Scopes::addresses(occurrence.source))
		}
		sendAnswerLock.unlock
	}
	
	/** 
	 * Relâche le token et se met en attente
	 */
	def relaseToken {
		emit(new TokenReleased)
	}
	/** 
	 * Calcul la différence entre les candidats potentiels et les candidats qui ont été sujets d'un AskForCandidate
	 */
	def nextCandidateToTest : Integer{
		candidatesAskedLock.lock
		for (candidate : candidates) {
			if (!candidatesAsked.contains(candidate)) {
				candidatesAsked.add(candidate)
				this.candidateInTest = candidate
				candidatesAskedLock.unlock
				clearAnswers
				return candidate
			}
		}
		candidatesAskedLock.unlock
		return null
	}
	
	def clearAnswers {
		for (id : answersReceived.keySet) {
			answersReceivedLock.lock
			answersReceived.put(id, 0)
			answersReceivedLock.unlock
			answersFalseReceivedLock.lock
			answersFalseReceived.put(id, 0)
			answersFalseReceivedLock.unlock
		}
		waitingAnswers = false
	}
	
	def emitSolution(v : Integer) {
		info("Solution has been found : " + v)
		resolvingLock.lock
		resolving = false
		resolvingLock.unlock
		values.add(v)
		emitToAllHolons(new SolutionFound => [solution = v; x = this.x; y = this.y])
		relaseToken
//		killMe
	}

	def emitToAllHolons(e : Event) {
		emit(e)		
		rowCtxId.^space.emit(e)		
		colCtxId.^space.emit(e)	
	}
	
	def searchOtherHolon {
		for (e : answersReceived.entrySet) {
			if(e.value != 0){
				spaces.get(e.key).emit(new AskForCandidate => [value = candidateInTest])
				break
			}
		}
	}

}

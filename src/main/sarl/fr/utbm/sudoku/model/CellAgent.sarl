/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.events.AnswerForCandidate
import fr.utbm.sudoku.events.AskForCandidate
import fr.utbm.sudoku.events.PositionX
import fr.utbm.sudoku.events.PositionY
import fr.utbm.sudoku.events.ReadyToResolve
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SendMessages
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.UUID
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent CellAgent {
	uses Logging, ExternalContextAccess, DefaultContextInteractions, SudokuMaths, Behaviors

	var x : Integer
	var y : Integer
	var rowCtxId : ContextContainer
	var colCtxId : ContextContainer
	var rowJoined : boolean
	var colJoined : boolean
	var nbValuesReceived = new Integer(0)
	var values = new HashSet<Integer>
	var valuesLock = new ReentrantLock
	var resolving = true
	var scanning = false
	
	var answers = new HashSet<AnswerForCandidate>

	var answersFalseReceived = new HashMap<RegionTypeEnum, Integer>
	var spaces = new HashMap<RegionTypeEnum, EventSpace>

	var candidateInTest : Integer
	var candidateInTestLock = new ReentrantLock

	var nbValuesReceivedLock = new ReentrantLock
	var answersReceivedLock = new ReentrantLock
	var answersFalseReceivedLock = new ReentrantLock
	var candidatesLock = new ReentrantLock
	var resolvingLock = new ReentrantLock
	var candidates = new ArrayList<Integer>
	var candidatesAskedLock = new ReentrantLock
	var candidatesAsked = new ArrayList<Integer>
	var agentWhoAnswered = new HashMap<RegionTypeEnum, HashSet<UUID>>

	on Initialize {
		if (occurrence.parameters.length >= 4) {
			rowCtxId = occurrence.parameters.get(0) as ContextContainer
			colCtxId = occurrence.parameters.get(1) as ContextContainer
			x = occurrence.parameters.get(2) as Integer // row
			y = occurrence.parameters.get(3) as Integer // col
			loggingName = "Cell n° (" + x + "," + y + ")"
			join(rowCtxId.contextId, rowCtxId.^space.spaceID.ID)
			join(colCtxId.contextId, colCtxId.^space.spaceID.ID)
		}

		answersFalseReceived.put(RegionTypeEnum.BLOC, 0)
		answersFalseReceived.put(RegionTypeEnum.LIGNE, 0)
		answersFalseReceived.put(RegionTypeEnum.COLONNE, 0)

		spaces.put(RegionTypeEnum.BLOC, defaultSpace)
		spaces.put(RegionTypeEnum.LIGNE, rowCtxId.^space)
		spaces.put(RegionTypeEnum.COLONNE, colCtxId.^space)
		
		agentWhoAnswered.put(RegionTypeEnum.BLOC, new HashSet)
		agentWhoAnswered.put(RegionTypeEnum.LIGNE, new HashSet)
		agentWhoAnswered.put(RegionTypeEnum.COLONNE, new HashSet)
		
		setSkill(new SudokuMathsBaseSkill(values), SudokuMaths)
		wake(new SendMessages)
	}

	on ContextJoined {
		if (occurrence.holonContextID.equals(rowCtxId.contextId)) {
			rowJoined = true
			rowCtxId.^space.emit(
				new PositionX(y, getID),
				Scopes.addresses(rowCtxId.^space.getAddress(rowCtxId.id))
			)
		}
		if (occurrence.holonContextID.equals(colCtxId.contextId)) {
			colJoined = true
			colCtxId.^space.emit(
				new PositionY(x, getID),
				Scopes.addresses(colCtxId.^space.getAddress(colCtxId.id))
			)
		}
	}

	on TokenReceived {
		wake(new Resolve)
	}

	on Values {
		nbValuesReceivedLock.lock
		values.addAll(occurrence.values)
		nbValuesReceived++
		if (nbValuesReceived == 3) {
			nbValuesReceivedLock.unlock
			emit(new ReadyToResolve)
		} else {
			nbValuesReceivedLock.unlock
		}
	}
	/** 
	 * L'agent commence la résolution du sudoku
	 */
	on Resolve [resolving] {
		var hasAtLeasteOneCandidate = false
		var candidate : Integer = null
		candidatesLock.lock
		candidates = evaluateCandidates
		if (candidates.size == 1) {
			candidate = candidates.get(0)
		} else if (candidates.size > 1) {
			hasAtLeasteOneCandidate = true
		}
		candidatesLock.unlock
		if (candidate !== null) {
			var c = candidate
			// S'il reste un seul candidat, on émet une solution puis on se suicide
			emitSolution(c)
		} else if (hasAtLeasteOneCandidate && !scanning) {
			// Sinon s'il y a plus d'un candidat on va essayer de trouver ceux pour lesquel aucune autre solution n'est possible
			scanning = true
			nextCandidateToTest
			if (candidateInTest !== null) {
				emit(new AskForCandidate(candidateInTest, RegionTypeEnum.BLOC))
			}
		}
	}
	/** 
	 * L'agent reçoit une réponse à son AskForCandidate
	 * Si aucun agent d'un des holons partagés ne peut recevoir le candidat, alors on a une solution
	 */
	on AnswerForCandidate [
		 resolving &&
		!isFromMe && 
		!agentWhoAnswered.get(occurrence.type).contains(occurrence.source.UUID)	
	] {

		var solutionFound = false
		var type = occurrence.type
		var ^space = spaces.get(type)

		answers.add(occurrence)
		answersReceivedLock.lock
		agentWhoAnswered.get(occurrence.type).add(occurrence.source.UUID)
		answersReceivedLock.unlock

		if (occurrence.answer == false) {
			answersFalseReceivedLock.lock
			var nbAnswersFalse = answersFalseReceived.get(type)
			nbAnswersFalse++
			answersFalseReceived.put(type, nbAnswersFalse);
			answersFalseReceivedLock.unlock
			if (nbAnswersFalse == ^space.participants.size - 2) {
				solutionFound = true
			}
		}
		if (solutionFound) {
			emitSolution(occurrence.value)
		} else {
			answersReceivedLock.lock
			var nb = agentWhoAnswered.get(type).size
			var p = ^space.participants.size - 2
			answersReceivedLock.unlock
			if (nb == p) {
				var nextType : RegionTypeEnum = null
				candidateInTestLock.lock
				switch (type) {
					case BLOC:
						nextType = RegionTypeEnum.COLONNE
					case COLONNE:
						nextType = RegionTypeEnum.LIGNE
					case LIGNE: {
						nextType = RegionTypeEnum.BLOC
						if (nextCandidateToTest === null) {
							scanning = false
							relaseToken
						}
					}
				}
				var e = new AskForCandidate(candidateInTest, nextType)
				if (candidateInTest !== null) {
					e.emitToHolon(nextType)
				}
				candidateInTestLock.unlock
			}
			if(nb > p){
				info("PB")
			}
		}

	}
	/** 
	 * Une solution a été trouvée dans un holon de l'agent
	 */
	on SolutionFound [!occurrence.isFromMe] {
		valuesLock.lock
		if (!values.contains(occurrence.solution)) {
			values.add(occurrence.solution)
			valuesLock.unlock
			clearAnswers
			candidatesLock.lock
			if (candidates.contains(occurrence.solution)){
				candidates.remove(occurrence.solution)
			}
			if (candidatesAsked.contains(occurrence.solution)) {
				candidatesAsked.remove(occurrence.solution)
			}
//			if (candidates.size !== 0) {
//				candidateInTest = candidates.get(0)
//			}
			candidatesLock.unlock
			wake(new Resolve)
		} else {
			valuesLock.unlock
		}
	}
	/** 
	 * L'agent reçoit une demande d'un autre agent pour s'avoir s'il peut acceuilir le candidat passé en paramètre
	 */
	on AskForCandidate [
		!isFrom(spaces.get(RegionTypeEnum.BLOC).getAddress(ID)) &&
		!isFrom(spaces.get(RegionTypeEnum.LIGNE).getAddress(ID)) &&
		!isFrom(spaces.get(RegionTypeEnum.COLONNE).getAddress(ID))	
	] {
		candidatesLock.lock
		candidates = evaluateCandidates
		val answerEvent = new AnswerForCandidate => [
			answer = candidates.contains(occurrence.value);
			value = new Integer(occurrence.value);
			x = this.x;
			y = this.y;
			type = occurrence.type;
		]
		candidatesLock.unlock
		answerEvent.source = spaces.get(occurrence.type).getAddress(ID)
		spaces.get(occurrence.type).emit(answerEvent, Scopes::addresses(occurrence.source))
	}
	/** 
	 * Relâche le token et se met en attente
	 */
	def relaseToken {
		clearAnswers
		candidatesAsked = new ArrayList<Integer>
		answers.clear
		emit(new TokenReleased)
	}
	/** 
	 * Calcul la différence entre les candidats potentiels et les candidats qui ont été sujets d'un AskForCandidate
	 */
	def nextCandidateToTest : Integer {
		candidatesAskedLock.lock
		for (candidate : candidates) {
			if (!candidatesAsked.contains(candidate)) {
				candidatesAsked.add(candidate)
				this.candidateInTest = candidate
				candidatesAskedLock.unlock
				clearAnswers
				return candidate
			}
		}
		candidatesAskedLock.unlock
		this.candidateInTest = null
		return null
	}

	def clearAnswers {
		for (id : RegionTypeEnum.values) {
			answersReceivedLock.lock
			agentWhoAnswered.put(id,new HashSet)
			answersReceivedLock.unlock
			answersFalseReceivedLock.lock
			answersFalseReceived.put(id, 0)
			answersFalseReceivedLock.unlock
		}
	}

	def emitSolution(v : Integer) {
		// info("Solution has been found : " + v)
		resolving = false
		values.add(v)
		emitToAllHolons(new SolutionFound => [solution = v; x = this.x; y = this.y])
		relaseToken
		// killMe
	}

	def emitToAllHolons(e : Event) {
		e.emitToHolon(RegionTypeEnum.BLOC)
		e.emitToHolon(RegionTypeEnum.LIGNE)
		e.emitToHolon(RegionTypeEnum.COLONNE)
	}

	def emitToHolon(e : Event, type : RegionTypeEnum) {
		var ^space = spaces.get(type)
		e.source = ^space.getAddress(ID)
		^space.emit(e)
	}
	
	def searchSingleton {
		var candidate : Integer = null
		candidatesLock.lock
		candidates = evaluateCandidates
		if (candidates.size == 1) {
			candidate = candidates.get(0)
		}
		candidatesLock.unlock
		if (candidate !== null) {
			var c = candidate
			emitSolution(c)
		}
	}
	
//	def determine

}

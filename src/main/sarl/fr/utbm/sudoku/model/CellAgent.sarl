/** 
 * 
 */
package fr.utbm.sudoku.model

import fr.utbm.sudoku.events.AnswerForCandidate
import fr.utbm.sudoku.events.AskForCandidate
import fr.utbm.sudoku.events.PositionX
import fr.utbm.sudoku.events.PositionY
import fr.utbm.sudoku.events.Resolve
import fr.utbm.sudoku.events.SolutionFound
import fr.utbm.sudoku.events.TokenReceived
import fr.utbm.sudoku.events.TokenReleased
import fr.utbm.sudoku.events.Values
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.UUID
import java.util.concurrent.locks.ReentrantLock

/** 
 * @author Clément Bareth-Desgranges <clement.bareth@gmail.com>
 * 
 */
agent CellAgent {
	uses Logging, ExternalContextAccess, DefaultContextInteractions, SudokuMaths, Behaviors, Lifecycle

	var x : Integer
	var y : Integer
	var rowCtxId : ContextContainer
	var colCtxId : ContextContainer
	var rowJoined : boolean
	var colJoined : boolean
	var nbValuesReceived = new Integer(0)
	
	var values = new HashSet<Integer>
	var valuesLock = new ReentrantLock
	
	var resolving = true
	
	
	var answersReceived = new HashMap<UUID,Integer>
	var answersFalseReceived = new HashMap<UUID, Integer>
	var spaces = new HashMap<UUID,EventSpace>
	
	
	var candidateInTest : Integer

	var nbValuesReceivedLock = new ReentrantLock
	var answersReceivedLock = new ReentrantLock
	var answersFalseReceivedLock = new ReentrantLock
	
	var candidatesLock = new ReentrantLock
	var resolvingLock = new ReentrantLock

	var candidates = new ArrayList<Integer>
	var candidatesAsked = new ArrayList<Integer>

	on Initialize {
		if (occurrence.parameters.length >= 4) {
			rowCtxId = occurrence.parameters.get(0) as ContextContainer
			colCtxId = occurrence.parameters.get(1) as ContextContainer
			x = occurrence.parameters.get(2) as Integer // row
			y = occurrence.parameters.get(3) as Integer // col
			loggingName = "Cell n° (" + x + "," + y + ")"
			join(rowCtxId.contextId, rowCtxId.^space.spaceID.ID)
			join(colCtxId.contextId, colCtxId.^space.spaceID.ID)
		}
		answersReceived.put(defaultContext.ID, 0)
		answersReceived.put(rowCtxId.id, 0)
		answersReceived.put(colCtxId.id, 0)

		answersFalseReceived.put(defaultContext.ID, 0)
		answersFalseReceived.put(rowCtxId.id, 0)
		answersFalseReceived.put(colCtxId.id, 0)

		spaces.put(defaultContext.ID, defaultSpace)
		spaces.put(rowCtxId.id, rowCtxId.^space)
		spaces.put(colCtxId.id, colCtxId.^space)
		
		setSkill(new SudokuMathsBaseSkill(values), SudokuMaths)
	}

	on ContextJoined {
		if (occurrence.holonContextID.equals(rowCtxId.contextId)) {
			rowJoined = true
			rowCtxId.^space.emit(
				new PositionX(y, getID),
				Scopes.addresses(rowCtxId.^space.getAddress(rowCtxId.id))
			)
		}
		if (occurrence.holonContextID.equals(colCtxId.contextId)) {
			colJoined = true
			colCtxId.^space.emit(
				new PositionY(x, getID),
				Scopes.addresses(colCtxId.^space.getAddress(colCtxId.id))
			)
		}
	}

	on TokenReceived {
		wake(new Resolve)
	}

	on Values {
		nbValuesReceivedLock.lock
		values.addAll(occurrence.values)
		nbValuesReceived++
		if (nbValuesReceived == 3) {
		// emit(new ReadyToResolve)
			nbValuesReceivedLock.unlock
			wake(new Resolve)
		} else {
			nbValuesReceivedLock.unlock
		}
	}
	/** 
	 * L'agent commence la résolution du sudoku
	 */
	on Resolve{
		var hasAtLeasteOneCandidate = false
		var candidate : Integer = null
		var isResolving = true;

		resolvingLock.lock
		isResolving = resolving
		resolvingLock.unlock
		
		if(isResolving){
			candidatesLock.lock
			candidates = evaluateCandidates
			if (candidates.size == 1) {
				candidate = candidates.get(0)
			} else if (candidates.size > 1) {
				hasAtLeasteOneCandidate = false
			}
			candidatesLock.unlock
	
			if (candidate !== null) {
				var c = candidate
				resolvingLock.lock
				resolving = false
				resolvingLock.unlock
				// S'il reste un seul candidat, on émet une solution puis on se suicide
				emitToAllHolons(new SolutionFound => [solution = c; x = this.x; y = this.y])		
//				killMe
			} 
			else if (hasAtLeasteOneCandidate) {
				// Sinon s'il y a plus d'un candidat on va essayer de trouver ceux pour lesquel aucune autre solution n'est possible
				var nextCandidate = nextCandidateToTest
				if (nextCandidate !== null) {
					emitToAllHolons(new AskForCandidate => [value = nextCandidate])
				}
			 }
		}
	}

	/** 
	 * L'agent reçoit une réponse à son AskForCandidate
	 * Si aucun agent d'un des holons partagés ne peut recevoir le candidat, alors on a une solution
	 */
	on AnswerForCandidate {
		var ctxId : UUID
		var ^space : EventSpace
		var solutionFound = false
		
		if (occurrence.isInDefaultSpace) {
			ctxId = defaultContext.ID
			^space = defaultSpace
		} else if (occurrence.isInSpace(rowCtxId.^space)) {
			ctxId = rowCtxId.id
			^space = rowCtxId.^space
		} else if (occurrence.isInSpace(colCtxId.^space)) {
			ctxId = colCtxId.id
			^space = colCtxId.^space
		}

		answersReceivedLock.lock
		var nbAnswers = answersReceived.get(ctxId)
		nbAnswers ++
		answersReceived.put(ctxId, nbAnswers);
		answersReceivedLock.unlock
		
		if (occurrence.answer == false) {
			answersFalseReceivedLock.lock
			var nbAnswersFalse = answersFalseReceived.get(ctxId)
			nbAnswersFalse++
			answersFalseReceived.put(ctxId, nbAnswersFalse);
			if (nbAnswersFalse == ^space.participants.size - 2) {
				solutionFound = true
			}
			answersFalseReceivedLock.unlock
		}
		
		if (solutionFound) {
			resolvingLock.lock
			resolving = false
			resolvingLock.unlock
			emitToAllHolons(new SolutionFound => [solution = occurrence.value; x = this.x; y = this.y])
//			killMe
		} else{
			var searchForCandidateIsOver = true
			answersReceivedLock.lock
			for(entry : answersReceived.entrySet){
				var nbAnswersReceived = entry.value
				var participants = spaces.get(entry.key).participants.size - 2
				if (participants != nbAnswersReceived) {
					searchForCandidateIsOver = false
				}
			}
			answersReceivedLock.unlock
			if (searchForCandidateIsOver) {
				// Pas de solution trouvée et toutes les réponses sont arrivées donc on remet les compteurs à 0			
				for (id : answersReceived.keySet) {
					answersReceived.put(id, 0)
					answersFalseReceived.put(id, 0)
				}
				wake (new Resolve)
			}
		}
	}
	/** 
	 * Une solution a été trouvée dans un holon de l'agent
	 */
	on SolutionFound [!occurrence.isFromMe] {
		valuesLock.lock
		if (!values.contains(occurrence.solution)){
			values.add(occurrence.solution)
			valuesLock.unlock
			wake(new Resolve)
		} else {
			valuesLock.unlock
		}
	}
	/** 
	 * L'agent reçoit une demande d'un autre agent pour s'avoir s'il peut acceuilir le candidat passé en paramètre
	 */
	on AskForCandidate [!it.isFrom(ID)] {
		var answerEvent : AnswerForCandidate
		
		candidatesLock.lock
		candidates = evaluateCandidates
		answerEvent = new AnswerForCandidate => [
			answer = candidates.contains(occurrence.value);
			value = new Integer(occurrence.value)
		]
		candidatesLock.unlock
		
		if (occurrence.isInDefaultSpace) {
			emit(answerEvent,
				Scopes::addresses(occurrence.source))
		} else if (occurrence.isInSpace(rowCtxId.^space)) {
			rowCtxId.^space.emit(answerEvent,
				Scopes::addresses(occurrence.source))
		} else if (occurrence.isInSpace(colCtxId.^space)) {
			colCtxId.^space.emit(answerEvent,
				Scopes::addresses(occurrence.source))
		}
	}
	/** 
	 * Relâche le token et se met en attente
	 */
	def relaseToken {
		emit(new TokenReleased)
	}
	/** 
	 * Calcul la différence entre les candidats potentiels et les candidats qui ont été sujets d'un AskForCandidate
	 */
	def nextCandidateToTest : Integer {
		for (candidate : candidates) {
			if (!candidatesAsked.contains(candidate)) {
				candidatesAsked.add(candidate)
				this.candidateInTest = candidate
				return candidate
			}
		}
	}

	def emitToAllHolons(e : Event) {
		emit(e)
		rowCtxId.^space.emit(e)
		colCtxId.^space.emit(e)
	}
	
//	on Destroy {
////		leave(rowCtxId.contextId)
////		leave(colCtxId.contextId)
//	}
}
		